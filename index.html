<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Spelling check</title>
<style>

:root{
  --bg0:#070b10;
  --bg1:#0b1620;
  --panel:#0f1620cc;
  --panel2:#0b121acc;
  --stroke:#2a3a4f;
  --stroke2:#1b2635;
  --text:#e9f2ff;
  --muted:#9db0c7;
  --accent:#45e6ff;
  --accent2:#9cff6b;
  --danger:#ff5a6a;
  --warn:#ffcc66;
  --radius:18px;
}

*{box-sizing:border-box;}
html,body{height:100%;}
body{
  margin:0;
  color:var(--text);
  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "Noto Sans JP", sans-serif;
  background:
    radial-gradient(1200px 700px at 15% 0%, rgba(69,230,255,0.18), transparent 55%),
    radial-gradient(900px 600px at 85% 15%, rgba(156,255,107,0.12), transparent 55%),
    linear-gradient(135deg, var(--bg0), var(--bg1));
  overflow-x:hidden;
}

.bgNoise{
  position:fixed; inset:0;
  pointer-events:none;
  background:
    linear-gradient(rgba(255,255,255,0.035) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255,255,255,0.025) 1px, transparent 1px);
  background-size: 34px 34px;
  mix-blend-mode: overlay;
  opacity:0.25;
}

#app{
  max-width: 1120px;
  margin: 0 auto;
  padding: 18px 16px 28px;
}

.topbar{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:14px;
  padding: 14px 16px;
  border:1px solid rgba(69,230,255,0.18);
  border-radius: 22px;
  background: linear-gradient(180deg, rgba(15,22,32,0.78), rgba(11,18,26,0.72));
  box-shadow: 0 18px 50px rgba(0,0,0,0.35);
  position:relative;
  overflow:hidden;
}

.topbar:before{
  content:"";
  position:absolute; inset:-2px;
  background:
    radial-gradient(500px 140px at 20% -10%, rgba(69,230,255,0.25), transparent 60%),
    radial-gradient(500px 160px at 80% 120%, rgba(156,255,107,0.15), transparent 55%);
  pointer-events:none;
}

.brand{
  display:flex;
  align-items:center;
  gap:12px;
  position:relative;
  z-index:1;
}

.mark{
  width:38px; height:38px;
  border-radius: 12px;
  border:1px solid rgba(69,230,255,0.35);
  background:
    conic-gradient(from 220deg, rgba(69,230,255,0.95), rgba(156,255,107,0.8), rgba(69,230,255,0.2), rgba(69,230,255,0.95));
  clip-path: polygon(12% 0%, 88% 0%, 100% 22%, 100% 78%, 88% 100%, 12% 100%, 0% 78%, 0% 22%);
  box-shadow: 0 10px 30px rgba(69,230,255,0.12);
}

.brandTitle{
  font-weight:800;
  letter-spacing:0.12em;
  font-size: 13px;
  text-transform:uppercase;
  opacity:0.95;
}

.brandSub{
  font-size: 12px;
  color: var(--muted);
  margin-top: 2px;
}

.status{
  display:flex;
  gap:10px;
  align-items:center;
  justify-content:flex-end;
  flex-wrap:wrap;
  position:relative;
  z-index:1;
}

.chip{
  padding: 8px 10px;
  border-radius: 999px;
  border:1px solid rgba(255,255,255,0.12);
  background: rgba(0,0,0,0.18);
  font-size: 12px;
  letter-spacing:0.08em;
  text-transform:uppercase;
  color: rgba(233,242,255,0.92);
  backdrop-filter: blur(8px);
}

#lockChip{
  border-color: rgba(69,230,255,0.30);
  box-shadow: 0 0 0 1px rgba(69,230,255,0.08) inset;
}

#lockChip.live{
  border-color: rgba(156,255,107,0.45);
  box-shadow: 0 0 0 1px rgba(156,255,107,0.12) inset, 0 0 26px rgba(156,255,107,0.10);
}

#stats{
  color: rgba(233,242,255,0.80);
  border-color: rgba(255,255,255,0.10);
}

.grid{
  margin-top: 14px;
  display:grid;
  grid-template-columns: 1fr 320px;
  grid-template-areas: "main side";
  gap: 14px;
}

@media (max-width: 980px){
  .grid{
    grid-template-columns: 1fr;
    grid-template-areas:
      "side"
      "main";
  }
}

.panel{
  border-radius: var(--radius);
  border: 1px solid rgba(255,255,255,0.10);
  background: linear-gradient(180deg, rgba(15,22,32,0.80), rgba(11,18,26,0.72));
  box-shadow: 0 18px 55px rgba(0,0,0,0.38);
  position:relative;
  overflow:hidden;
}

.panel:before{
  content:"";
  position:absolute; inset:0;
  background:
    linear-gradient(90deg, rgba(69,230,255,0.11), transparent 40%),
    linear-gradient(270deg, rgba(156,255,107,0.08), transparent 45%);
  opacity:0.55;
  pointer-events:none;
}

.panelMain{ padding: 16px; grid-area: main; }
.panelSide{ padding: 14px; grid-area: side; }

.hudTop{
  display:flex;
  gap: 14px;
  align-items:flex-start;
  justify-content:space-between;
  flex-wrap:wrap;
}

.block{
  flex: 1 1 480px;
  min-width: 280px;
}

.blockSmall{
  flex: 0 0 220px;
  min-width: 220px;
}

.label{
  font-size: 11px;
  letter-spacing:0.18em;
  text-transform:uppercase;
  color: rgba(157,176,199,0.95);
  margin-bottom: 8px;
}

#jp{
  font-size: clamp(38px, 5.4vw, 64px);
  margin: 0;
  text-align:center;
  font-weight: 850;
  letter-spacing: 0.02em;
  text-shadow: 0 10px 36px rgba(0,0,0,0.35);
}

#timer{
  font-size: clamp(18px, 2.8vw, 30px);
  opacity: 0.92;
  margin: 0;
  text-align:center;
  font-weight: 700;
  color: rgba(233,242,255,0.90);
}

.answerBlock{
  margin-top: 14px;
  padding: 12px 12px;
  border-radius: 16px;
  border: 1px solid rgba(69,230,255,0.12);
  background: rgba(0,0,0,0.18);
}

#reveal{
  font-size: clamp(30px, 4.4vw, 56px);
  min-height: 58px;
  margin: 4px 0 0;
  text-align:center;
  font-weight: 800;
  letter-spacing: 0.01em;
  color: rgba(233,242,255,0.88);
}

#reveal.shown{
  color: rgba(156,255,107,0.95);
  text-shadow: 0 10px 40px rgba(156,255,107,0.10);
}

.padWrap{
  margin-top: 14px;
  position:relative;
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(0,0,0,0.15);
  padding: 10px;
}

.padWrap:before{
  content:"";
  position:absolute;
  inset:0;
  border-radius: 18px;
  pointer-events:none;
  box-shadow: 0 0 0 1px rgba(69,230,255,0.10) inset;
}

canvas{
  width: 100%;
  height: 300px;
  border-radius: 14px;
  border: 2px solid rgba(69,230,255,0.25);
  background: #ffffff;
  touch-action: none;
  display:block;
}

.padOverlay{
  position:absolute;
  inset: 10px;
  border-radius: 14px;
  display:flex;
  align-items:center;
  justify-content:center;
  background:
    linear-gradient(180deg, rgba(7,11,16,0.55), rgba(7,11,16,0.72));
  border: 1px solid rgba(255,255,255,0.10);
  backdrop-filter: blur(6px);
  transition: opacity 180ms ease, transform 180ms ease;
}

.padOverlay.hidden{
  opacity:0;
  transform: translateY(6px);
  pointer-events:none;
}

.padOverlayCard{
  padding: 14px 16px;
  border-radius: 14px;
  border: 1px solid rgba(69,230,255,0.18);
  background: rgba(0,0,0,0.22);
  text-align:center;
  max-width: 420px;
}

.padOverlayTitle{
  font-weight:900;
  letter-spacing:0.18em;
  text-transform:uppercase;
  font-size: 12px;
  color: rgba(69,230,255,0.95);
}

.padOverlayText{
  margin-top: 8px;
  color: rgba(233,242,255,0.88);
  font-size: 14px;
}
.padOverlayBtn{
  margin-top: 12px;
  min-width: 180px;
}

.miniStart{
  width: 100%;
  margin-top: 10px;
  padding: 12px 14px;
  font-size: 14px;
}

.sideTitle{
  font-weight:900;
  letter-spacing:0.16em;
  text-transform:uppercase;
  font-size: 12px;
  color: rgba(233,242,255,0.90);
  margin-bottom: 12px;
}

.btnGrid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}

.btn{
  appearance:none;
  border:1px solid rgba(255,255,255,0.14);
  border-radius: 14px;
  padding: 12px 12px;
  font-weight: 900;
  letter-spacing:0.12em;
  text-transform:uppercase;
  font-size: 12px;
  color: rgba(233,242,255,0.92);
  background: rgba(0,0,0,0.18);
  cursor:pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease, opacity 120ms ease;
  position:relative;
  overflow:hidden;
}

.btn:before{
  content:"";
  position:absolute; inset:0;
  background: linear-gradient(90deg, rgba(255,255,255,0.08), transparent 55%);
  opacity:0;
  transition: opacity 150ms ease;
  pointer-events:none;
}

.btn:hover:before{opacity:1;}
.btn:hover{
  transform: translateY(-1px);
  border-color: rgba(69,230,255,0.22);
  box-shadow: 0 10px 30px rgba(0,0,0,0.25);
}

.btn:active{ transform: translateY(0px); }

.btn:disabled{
  opacity:0.40;
  cursor:not-allowed;
  transform:none;
  box-shadow:none;
}

.btn.primary{
  border-color: rgba(69,230,255,0.36);
  background: linear-gradient(180deg, rgba(69,230,255,0.18), rgba(0,0,0,0.18));
  box-shadow: 0 0 0 1px rgba(69,230,255,0.08) inset;
}

.btn.primary.running{
  border-color: rgba(156,255,107,0.50);
  box-shadow: 0 0 0 1px rgba(156,255,107,0.14) inset, 0 0 34px rgba(156,255,107,0.12);
}

.btn.secondary{
  border-color: rgba(255,255,255,0.18);
}

.btn.ghost{
  border-color: rgba(255,255,255,0.14);
}

.btn.good{
  border-color: rgba(156,255,107,0.45);
  background: linear-gradient(180deg, rgba(156,255,107,0.12), rgba(0,0,0,0.18));
}

.btn.bad{
  border-color: rgba(255,90,106,0.55);
  background: linear-gradient(180deg, rgba(255,90,106,0.14), rgba(0,0,0,0.18));
}

.miniBtn{
  appearance:none;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(0,0,0,0.25);
  color: rgba(233,242,255,0.92);
  border-radius: 10px;
  padding: 6px 10px;
  cursor:pointer;
  font-weight: 900;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  font-size: 11px;
}
.miniBtn:hover{
  border-color: rgba(69,230,255,0.32);
}
.miniBtn:active{
  transform: translateY(1px);
}

.sideWindow{
  margin-top: 12px;
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,0.14);
  background: linear-gradient(180deg, rgba(69,230,255,0.08), rgba(0,0,0,0.18));
  box-shadow: 0 14px 40px rgba(0,0,0,0.35);
  overflow: hidden;
}

.sideWindowTitle{
  padding: 10px 12px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  font-weight: 900;
  letter-spacing: 0.16em;
  text-transform: uppercase;
  font-size: 11px;
  color: rgba(233,242,255,0.92);
  border-bottom: 1px solid rgba(255,255,255,0.12);
  background: linear-gradient(90deg, rgba(69,230,255,0.10), rgba(0,0,0,0.0));
}

.sideWindowBody{
  max-height: 290px;
  overflow: auto;
  padding: 10px 10px 12px 10px;
}

.sideWindowBody::-webkit-scrollbar{ width: 10px; }
.sideWindowBody::-webkit-scrollbar-thumb{
  background: rgba(69,230,255,0.18);
  border: 2px solid rgba(0,0,0,0.25);
  border-radius: 10px;
}

.histItem{
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(0,0,0,0.20);
  padding: 10px 10px 9px 10px;
  margin-bottom: 8px;
}

.histJP{
  font-weight: 950;
  letter-spacing: 0.04em;
  font-size: 16px;
  color: rgba(233,242,255,0.96);
}

.histEN{
  margin-top: 4px;
  font-size: 12px;
  letter-spacing: 0.06em;
  text-transform: none;
  color: rgba(157,176,199,0.98);
}


.histRow{
  display:flex;
  gap: 10px;
  align-items:flex-start;
}
.histThumbBtn{
  padding:0;
  margin:0;
  border:0;
  background: transparent;
  cursor:pointer;
  flex: 0 0 auto;
}
.histThumb{
  width: 76px;
  height: 56px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.06);
  box-shadow: 0 10px 26px rgba(0,0,0,0.28);
  object-fit: contain;
  display:block;
}
.histThumbEmpty{
  width: 76px;
  height: 56px;
  border-radius: 12px;
  border: 1px dashed rgba(255,255,255,0.16);
  background: rgba(0,0,0,0.18);
}
.histText{
  flex: 1 1 auto;
  min-width: 0;
}
.histMeta{
  margin-top: 6px;
  font-size: 10px;
  color: rgba(157,176,199,0.75);
  letter-spacing: 0.06em;
  text-transform: uppercase;
}

.modalBackdrop{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.72);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  padding: 18px;
}

.modalBackdrop.open{display:flex;}
.modalCard{
  width: min(900px, 100%);
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,0.16);
  background: linear-gradient(180deg, rgba(24,34,48,0.96), rgba(0,0,0,0.78));
  box-shadow: 0 30px 120px rgba(0,0,0,0.60);
  overflow: hidden;
}
.modalHeader{
  display:flex;
  justify-content: space-between;
  align-items:center;
  padding: 12px 14px;
  border-bottom: 1px solid rgba(255,255,255,0.10);
}
.modalTitle{
  font-weight: 950;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  font-size: 12px;
  color: rgba(233,242,255,0.92);
}
.modalClose{
  border: 1px solid rgba(255,255,255,0.16);
  background: rgba(0,0,0,0.25);
  color: rgba(233,242,255,0.9);
  border-radius: 12px;
  padding: 8px 12px;
  cursor: pointer;
  font-weight: 900;
  letter-spacing: 0.04em;
}
.modalBody{
  padding: 14px;
}
.modalCaption{
  margin-bottom: 12px;
  text-align: center;
  display: grid;
  gap: 4px;
  justify-items: center;
}
.modalCaption .capJP{
  font-weight: 900;
  letter-spacing: 0.03em;
  font-size: clamp(18px, 2.1vw, 26px);
  color: rgba(183,201,225,0.95);
}
.modalCaption .capEN{
  margin-top: 2px;
  font-weight: 950;
  font-size: clamp(24px, 2.9vw, 38px);
  letter-spacing: 0.01em;
  text-transform: none; /* preserve original casing */
  color: rgba(233,242,255,0.98);
}
.modalImg{
  width: 100%;
  height: auto;
  border-radius: 14px;
  border: 2px solid rgba(69,230,255,0.22);
  background: #ffffff;
  display: block;
}
.modalCanvas{
  width: 100%;
  border-radius: 14px;
  border: 2px solid rgba(69,230,255,0.22);
  background: #ffffff;
  display: block;
}

.histEmpty{
  color: rgba(157,176,199,0.88);
  font-size: 12px;
  line-height: 1.4;
  padding: 4px 2px;
}

.hint{
  margin-top: 12px;
  padding: 12px;
  border-radius: 16px;
  border: 1px dashed rgba(255,255,255,0.18);
  color: rgba(157,176,199,0.95);
  font-size: 13px;
  line-height: 1.35;
}



.selfCheckRow{
  margin-top: 12px;
  display:flex;
  gap: 12px;
  justify-content:center;
  align-items:stretch;
}
.selfCheckRow .btn{
  flex: 1 1 240px;
  max-width: 360px;
}

@media (max-width: 900px){
  .selfCheckRow{
    gap:10px;
  }
  .selfCheckRow .btn{
    max-width: none;
  }
}

</style>
</head>
<body>
<div aria-hidden="true" class="bgNoise"></div>
<div id="app">
<header class="topbar">
<div class="brand">
<div aria-hidden="true" class="mark"></div>
<div>
<div class="brandTitle">Spelling check</div>
</div>
</div>
<div class="status">
<div class="chip" id="lockChip">LOCKED</div>
<div class="chip" id="stats">Score: 0 / 0 | Streak: 0</div>
</div>
</header>
<div class="grid">
<section class="panel panelMain">
<div class="hudTop">
<div class="block">
<div class="label">Japanese</div>
<div id="jp">—</div>
</div>
<div class="block blockSmall">
<div class="label">Timer</div>
<div id="timer">10.0s</div>
<button class="btn primary miniStart" id="startBtnMain" type="button">START</button>
</div>
</div>
<div class="answerBlock">
<div class="label">Correct answer</div>
<div id="reveal"></div>
</div>
<div class="padWrap" id="padWrap">
<canvas id="pad"></canvas>
<div class="padOverlay" id="padOverlay">
<div class="padOverlayCard">
<div class="padOverlayTitle">Pad locked</div>
<div class="padOverlayText">Press <b>START</b> to begin writing.</div>
<button class="btn primary padOverlayBtn" id="overlayStartBtn" type="button">START</button>
</div>
</div>
</div>
<div class="selfCheckRow" id="selfCheckRow" hidden>
  <button class="btn ghost" id="padClearBtn" type="button">CLEAR</button>
  <button class="btn good" disabled id="correctBtn" type="button">✅ CORRECT</button>
  <button class="btn bad" disabled id="wrongBtn" type="button">❌ WRONG</button>
</div>
</section>
<aside class="panel panelSide">
<div class="sideWindow" id="historyWindow">
  <div class="sideWindowTitle"><span>History</span><button class="miniBtn" id="clearHistoryBtn" type="button" title="Clear history">CLEAR</button></div>
  <div class="sideWindowBody" id="historyList" aria-label="History list"></div>
</div>
</aside>
</div>
</div>

<div id="inkModal" class="modalBackdrop" hidden aria-hidden="true">
  <div class="modalCard" role="dialog" aria-modal="true" aria-label="Handwriting preview">
    <div class="modalHeader">
      <div class="modalTitle">Handwriting</div>
      <button class="modalClose" id="modalClose" type="button">Close</button>
    </div>
    <div class="modalBody">
      <div class="modalCaption" id="modalCaption"></div>
      <img class="modalImg" id="modalImg" alt="Handwriting preview">
      <canvas class="modalCanvas" id="modalCanvas" aria-label="Handwriting canvas" style="display:none;"></canvas>
    </div>
  </div>
</div>

<script>
(() => {
  // ---- Questions ----
  const questions = [
    { jp: "曲がる", en: "turn" },
    { jp: "働く", en: "work" },
    { jp: "見る", en: "look" },
    { jp: "歩く", en: "walk" },
    { jp: "...終える", en: "finish" },
    { jp: "...がほしい", en: "want" },
    { jp: "心配する", en: "worry" },
    { jp: "買い物をする、店", en: "shop" },
    { jp: "走る", en: "run" },
    { jp: "...に会う", en: "meet" },
    { jp: "...が聞こえる", en: "hear" },
    { jp: "すわる", en: "sit" },
    { jp: "...と思う", en: "think" },
    { jp: "…を買う", en: "buy" },
    { jp: "…を飲む", en: "drink" },
    { jp: "(...を)歌う", en: "sing" },
    { jp: "…を与える", en: "give" },
    { jp: "(写真)をとる", en: "take" },
    { jp: "(...に) ~を見せる", en: "show" },
    { jp: "...を食べる", en: "eat" },
    { jp: "小さい、幼い", en: "little" },
    { jp: "若い", en: "young" },
    { jp: "新しい", en: "new" },
    { jp: "古い", en: "old" },
    { jp: "暑い", en: "hot" },
    { jp: "あたたかい", en: "warm" },
    { jp: "涼しい、かっこいい", en: "cool" },
    { jp: "寒い", en: "cold" },
    { jp: "簡単な", en: "easy" },
    { jp: "難しい", en: "difficult" },
    { jp: "幸せ", en: "happy" },
    { jp: "元気な", en: "fine" },
    { jp: "悲しい", en: "sad" },
    { jp: "申し訳なく思って", en: "sorry" },
    { jp: "すばらしい (g-)", en: "great" },
    { jp: "すばらしい (w-)", en: "wonderful" },
    { jp: "悪い", en: "bad" },
    { jp: "もう１つの", en: "another" },
    { jp: "人気のある", en: "popular" },
    { jp: "有名な", en: "famous" },
    { jp: "強い", en: "strong" },
    { jp: "昨日", en: "yesterday" },
    { jp: "今日", en: "today" },
    { jp: "明日", en: "tomorrow" },
    { jp: "今、現在", en: "now" },
    { jp: "ときどき", en: "sometimes" },
    { jp: "よく、しばしば", en: "often" },
    { jp: "ふつう、たいてい", en: "usually" },
    { jp: "いつも", en: "always" },
    { jp: "熱心に", en: "hard" },
  ];

  // Randomize question order (Fisher–Yates shuffle)
  function shuffleQuestions(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // ---- State ----
  let qi = 0;
  let running = false;
  let revealed = false;
    let loggedThis = false;
let everStarted = false;
  let timeLeftMs = 10_000;
  let lastTick = null;
  let rafId = null;

  let correct = 0;
  let total = 0;
  let streak = 0;

  
  // ---- History (previous prompts) ----
  const HISTORY_KEY = "spelling_check_history_v1";
  let history = [];
  try {
    history = JSON.parse(localStorage.getItem(HISTORY_KEY) || "[]");
    if (!Array.isArray(history)) history = [];
  } catch (e) { history = []; }


    function saveHistory() {
    try {
      localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
      return true;
    } catch (e) {
      // If storage is full (common on iPad Safari), drop oldest entries until it fits.
      // history is newest-first, so .pop() removes the oldest.
      while (history.length > 0) {
        try {
          history.pop();
          localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
          return true;
        } catch (e2) {
          // keep trimming
        }
      }
      return false;
    }
  }

    function simplifyStroke(stroke) {
    // Reduce point count to save storage + speed up redraws (keeps shape/legibility).
    if (!stroke || stroke.length < 3) return stroke || [];
    const out = [stroke[0]];
    let last = stroke[0];
    for (let i = 1; i < stroke.length - 1; i++) {
      const p = stroke[i];
      const dx = (p.x - last.x);
      const dy = (p.y - last.y);
      const dist2 = dx*dx + dy*dy;
      const dw = Math.abs((p.w || 0) - (last.w || 0));
      // Keep points that materially change the path/width.
      if (dist2 >= 1.44 || dw >= 0.35) { // ~1.2px threshold
        out.push(p);
        last = p;
      }
    }
    out.push(stroke[stroke.length - 1]);
    return out;
  }

  function packStrokes(strokesData, scale) {
    // Pack into integers to dramatically reduce JSON size (localStorage-friendly).
    const s = scale || 10;
    const packed = [];
    for (const st of (strokesData || [])) {
      const simp = simplifyStroke(st);
      const arr = [];
      for (const p of simp) {
        arr.push(Math.round((p.x || 0) * s), Math.round((p.y || 0) * s), Math.round((p.w || 2) * s));
      }
      packed.push(arr);
    }
    return { packed, scale: s };
  }

  function captureInkDataUrl() {
    // Capture handwriting for History:
    // - a small thumbnail image for the list
    // - packed vector strokes for crisp enlargement (modal redraw)
    if (!hasInk) return null;
    try {
      const rect = canvas.getBoundingClientRect();
      const baseW = Math.max(1, rect.width || 1);
      const baseH = Math.max(1, rect.height || 1);

      const strokesCopy = (strokes || []).map(st => (st || []).map(p => ({ x: p.x, y: p.y, w: p.w })));
      const { packed, scale } = packStrokes(strokesCopy, 10);

      // Compact thumbnail for the History list (modal preview will re-render from strokes at high-res)
      const thumbW = 560;
      const thumbH = Math.max(1, Math.round(thumbW * (baseH / baseW)));

      const tmp = document.createElement("canvas");
      tmp.width = thumbW;
      tmp.height = thumbH;

      const tctx = tmp.getContext("2d");
      tctx.imageSmoothingEnabled = true;
      try { tctx.imageSmoothingQuality = "high"; } catch (e) {}
      tctx.fillStyle = "#ffffff";
      tctx.fillRect(0, 0, thumbW, thumbH);

      // Draw from simplified (not packed) points for thumbnail.
      drawStrokesToCtx(tctx, strokesCopy.map(simplifyStroke), thumbW / baseW, thumbH / baseH);

      let url = null;
      try { url = tmp.toDataURL("image/webp", 0.88); } catch (e) {}
      if (!url || url === "data:,") {
        url = tmp.toDataURL("image/png");
      }

      return { thumb: url, strokesP: packed, strokesScale: scale, baseW, baseH };
    } catch (e) {
      return null;
    }
  }

  function renderHistory() {
    if (!historyEl) return;
    if (!history.length) {
      historyEl.innerHTML = '<div class="histEmpty">No entries yet.<br>Finish a round to add it here.</div>';
      return;
    }
    historyEl.innerHTML = history.map((item, idx) => {
      const jp = String(item.jp || "");
      const en = String(item.en || "");
      const ink = item.ink || item.handwriting || item.img || null;
      const at = item.at ? new Date(item.at) : null;
      const stamp = at ? at.toLocaleString(undefined, { month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit" }) : "";

      const thumb = ink
        ? `<button class="histThumbBtn" type="button" data-open-ink="${idx}" aria-label="Open handwriting">
             <img class="histThumb" src="${ink}" alt="Handwriting thumbnail" loading="lazy" decoding="async">
           </button>`
        : `<div class="histThumbEmpty" aria-hidden="true"></div>`;

      return `<div class="histItem">
        <div class="histRow">
          ${thumb}
          <div class="histText">
            <div class="histJP">${escapeHtml(jp)}</div>
            <div class="histEN">${escapeHtml(en)}</div>
            ${stamp ? `<div class="histMeta">${escapeHtml(stamp)}</div>` : ``}
          </div>
        </div>
      </div>`;
    }).join("");
  }

  function rememberAttempt(q, inkData, result) {
    if (!q) return;
    const entry = { jp: q.jp, en: q.en, res: result || "unknown", at: Date.now() };

    if (typeof inkData === "string") {
      entry.ink = inkData || null;
    } else if (inkData && typeof inkData === "object") {
      entry.ink = inkData.thumb || null;
      // store packed strokes for crisp re-render (much smaller than raw point objects)
      entry.strokesP = inkData.strokesP || null;
      entry.strokesScale = inkData.strokesScale || 10;
      entry.baseW = inkData.baseW || null;
      entry.baseH = inkData.baseH || null;
    } else {
      entry.ink = null;
    }

    history.unshift(entry);
    // keep it lightweight (history can grow fast)
    if (history.length > 40) history = history.slice(0, 40);
    saveHistory();
    renderHistory();
  }

  function getResultTag(item) {
    return (item && (item.res || item.result || item.status || item.outcome)) ? String(item.res || item.result || item.status || item.outcome) : "unknown";
  }

  function recomputeStatsFromHistory() {
    correct = 0;
    total = 0;
    streak = 0;

    // history is newest-first
    for (const item of history) {
      const r = getResultTag(item);
      total += 1;
      if (r === "correct") correct += 1;
    }
    for (const item of history) {
      if (getResultTag(item) === "correct") streak += 1;
      else break;
    }
    setStats();
  }

  function logCurrentIfNeeded(result) {
    if (loggedThis) return;
    const q = questions[qi];
    const ink = captureInkDataUrl();
    rememberAttempt(q, ink, result);
    loggedThis = true;
    // Keep score/streak derived from history so it stays accurate even after refresh.
    recomputeStatsFromHistory();
  }

  function openInk(idx) {
    if (!inkModal) return;
    const item = history[idx];
    if (!item) return;

    if (modalCaption) {
      modalCaption.innerHTML = `<div class="capJP">${escapeHtml(String(item.jp || ""))}</div>
        <div class="capEN">${escapeHtml(String(item.en || ""))}</div>`;
    }

    inkModal.hidden = false;
    inkModal.classList.add("open");
    inkModal.setAttribute("aria-hidden","false");

    // Render after the modal is visible so sizing is correct.
    requestAnimationFrame(() => renderInkPreview(item));
  }

  function renderInkPreview(item) {
    if (!item) return;

    // Prefer vector strokes for crisp enlargement.
    const hasPacked = Array.isArray(item.strokesP) && item.strokesP.length > 0;
    const hasObjStrokes = Array.isArray(item.strokes) && item.strokes.length > 0; // backward-compat
    const hasStrokes = hasPacked || hasObjStrokes;

    if (hasStrokes && modalCanvas) {
      if (modalImg) { modalImg.style.display = "none"; modalImg.removeAttribute("src"); }
      modalCanvas.style.display = "block";

      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const card = inkModal ? inkModal.querySelector(".modalCard") : null;
      const availW = Math.min(860, (card ? card.clientWidth : window.innerWidth) - 36);

      const baseW = Number(item.baseW) || 560;
      const baseH = Number(item.baseH) || 300;
      const ratio = baseH / baseW;

      const cssW = Math.max(320, availW);
      const cssH = Math.max(180, Math.round(cssW * ratio));

      modalCanvas.style.width = "100%";
      modalCanvas.style.height = cssH + "px";
      modalCanvas.width = Math.round(cssW * dpr);
      modalCanvas.height = Math.round(cssH * dpr);

      const c = modalCanvas.getContext("2d");
      c.setTransform(dpr, 0, 0, dpr, 0, 0);
      c.imageSmoothingEnabled = true;
      try { c.imageSmoothingQuality = "high"; } catch (e) {}
      c.clearRect(0, 0, cssW, cssH);
      c.fillStyle = "#ffffff";
      c.fillRect(0, 0, cssW, cssH);

      if (hasPacked) {
      drawPackedStrokesToCtx(c, item.strokesP, item.strokesScale || 10, cssW / baseW, cssH / baseH);
    } else {
      drawStrokesToCtx(c, item.strokes, cssW / baseW, cssH / baseH);
    }
      return;
    }

    // Fallback to stored image thumbnail.
    const ink = item.ink || item.handwriting || item.img || null;
    if (modalCanvas) modalCanvas.style.display = "none";
    if (!modalImg || !ink) return;
    modalImg.style.display = "block";
    modalImg.src = ink;
  }

  function closeInk() {
    if (!inkModal) return;
    inkModal.hidden = true;
    inkModal.classList.remove("open");
    inkModal.setAttribute("aria-hidden","true");
    if (modalImg) { modalImg.removeAttribute("src"); modalImg.style.display = "block"; }
    if (modalCanvas) {
      try {
        const c = modalCanvas.getContext("2d");
        c.clearRect(0, 0, modalCanvas.width, modalCanvas.height);
      } catch (e) {}
      modalCanvas.style.display = "none";
    }
    if (modalCaption) modalCaption.innerHTML = "";
  }




  function escapeHtml(s) {
    return s.replace(/[&<>"']/g, (c) => ({
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#039;"
    }[c]));
  }
// ---- Elements ----
  const jpEl = document.getElementById("jp");
  const timerEl = document.getElementById("timer");
  const revealEl = document.getElementById("reveal");
  const startBtnMain = document.getElementById("startBtnMain");
  const overlayStartBtn = document.getElementById("overlayStartBtn");
  const clearHistoryBtn = document.getElementById("clearHistoryBtn");
  const correctBtn = document.getElementById("correctBtn");
  const wrongBtn = document.getElementById("wrongBtn");
  const selfCheckRow = document.getElementById("selfCheckRow");
  const padClearBtn = document.getElementById("padClearBtn");
  const statsEl = document.getElementById("stats");

  
  const historyEl = document.getElementById("historyList");
  const historyWindow = document.getElementById("historyWindow");

  const inkModal = document.getElementById("inkModal");
  const modalCloseBtn = document.getElementById("modalClose");
  const modalImg = document.getElementById("modalImg");
  const modalCanvas = document.getElementById("modalCanvas");
  const modalCaption = document.getElementById("modalCaption");

  if (historyEl) {
    historyEl.addEventListener("click", (e) => {
      const btn = e.target.closest("[data-open-ink]");
      if (!btn) return;
      const idx = Number(btn.getAttribute("data-open-ink"));
      if (Number.isFinite(idx)) openInk(idx);
    });
  }

  if (modalCloseBtn) modalCloseBtn.addEventListener("click", closeInk);
  if (inkModal) {
    inkModal.addEventListener("click", (e) => {
      if (e.target === inkModal) closeInk();
    });
  }
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape") closeInk();
  });
  closeInk();
const padOverlay = document.getElementById("padOverlay");
  const lockChip = document.getElementById("lockChip");

  function syncUiState() {
    // Locked unless the countdown is actively running (and before reveal)
    const locked = !(running && !revealed);

    // Hard-disable pointer input when locked (extra safety)
    canvas.style.pointerEvents = locked ? "none" : "auto";

    if (padOverlay) {
      // Show the large overlay only on the very first idle state (before the user ever starts).
      // After a round ends (revealed=true), we keep the pad locked but do NOT obscure the handwriting.
      const showOverlay = locked && !revealed && !everStarted;
      padOverlay.classList.toggle("hidden", !showOverlay);
    }

    if (lockChip) {
      lockChip.textContent = locked ? "LOCKED" : "LIVE";
      lockChip.classList.toggle("live", !locked);
    }

    // History is viewable only when the timer isn't active (no cheating mid-countdown)
    if (historyWindow) {
      const showHistory = !running;
      historyWindow.hidden = !showHistory;
      historyWindow.setAttribute("aria-hidden", showHistory ? "false" : "true");
    }

    // Under-pad actions:
    // - While timer is running: show CLEAR (to erase and keep writing)
    // - After timer ends: show CORRECT / WRONG for self-check
    if (selfCheckRow) {
      const showRow = running || (revealed && !running);
      selfCheckRow.hidden = !showRow;
      selfCheckRow.setAttribute("aria-hidden", showRow ? "false" : "true");
    }
    if (padClearBtn) {
      const showClear = running && !revealed;
      padClearBtn.style.display = showClear ? "" : "none";
      padClearBtn.disabled = !showClear;
    }
    if (correctBtn) {
      const showMark = revealed && !running;
      correctBtn.style.display = showMark ? "" : "none";
      if (!showMark) correctBtn.disabled = true;
    }
    if (wrongBtn) {
      const showMark = revealed && !running;
      wrongBtn.style.display = showMark ? "" : "none";
      if (!showMark) wrongBtn.disabled = true;
    }

// JP prompt is visible only while the timer is actively running
    try {
      const q = questions[qi];
      jpEl.textContent = (running && !revealed) ? String(q && q.jp || "") : "";
    } catch (e) {
      jpEl.textContent = "";
    }
    // Timer button behavior:
    // - Idle: START
    // - Running: RUNNING… (disabled)
    // - After timer ends: no button until Correct/Wrong is chosen
    // - After chosen: NEXT (advance + auto-start)
    if (startBtnMain) {
      startBtnMain.classList.toggle("running", running);

      if (running && !revealed) {
        startBtnMain.style.display = "";
        startBtnMain.disabled = false;
        startBtnMain.textContent = "FINISH";
      } else if (!running && !revealed) {
        startBtnMain.style.display = "";
        startBtnMain.disabled = false;
        startBtnMain.textContent = "START";
      } else if (!running && revealed) {
        if (loggedThis) {
          startBtnMain.style.display = "";
          startBtnMain.disabled = false;
          startBtnMain.textContent = "NEXT";
        } else {
          startBtnMain.style.display = "none";
        }
      } else {
        startBtnMain.style.display = "none";
      }
    }

  }

  // ---- Canvas drawing (Option 1: just a writing pad) ----
  const canvas = document.getElementById("pad");
  const ctx = canvas.getContext("2d");
  let canvasCssW = 0;
  let canvasCssH = 0;

  function resizeCanvasToDisplaySize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvasCssW = Math.max(1, Math.floor(rect.width));
    canvasCssH = Math.max(1, Math.floor(rect.height));
    const w = Math.floor(canvasCssW * dpr);
    const h = Math.floor(canvasCssH * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
  }
  resizeCanvasToDisplaySize();
  window.addEventListener("resize", resizeCanvasToDisplaySize);

  let isDrawing = false;
  let hasInk = false;
  let lastP = null;

  // Vector capture for crisp history previews
  let strokes = [];
  let currentStroke = null;


  function canDraw() {
    // Only allow writing while the countdown is running (and before reveal)
    return running && !revealed;
  }

  function getPoint(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const pressure = (typeof e.pressure === "number" && e.pressure > 0) ? e.pressure : 0.5;
    const w = 2 + pressure * 6;
    return { x, y, w };
  }

  function drawStrokesToCtx(c, strokesData, sx, sy) {
    if (!strokesData || !strokesData.length) return;
    c.save();
    c.strokeStyle = "#111";
    c.lineCap = "round";
    c.lineJoin = "round";
    const s = Math.max(sx || 1, sy || 1);
    for (const stroke of strokesData) {
      if (!stroke || stroke.length < 2) continue;
      for (let i = 1; i < stroke.length; i++) {
        const a = stroke[i - 1];
        const b = stroke[i];
        const lw = ((a.w || 2) + (b.w || 2)) * 0.5 * s;
        c.lineWidth = Math.max(1, lw);
        c.beginPath();
        c.moveTo((a.x || 0) * sx, (a.y || 0) * sy);
        c.lineTo((b.x || 0) * sx, (b.y || 0) * sy);
        c.stroke();
      }
    }
    c.restore();
  }

  function drawPackedStrokesToCtx(c, packedStrokes, scale, sx, sy) {
    if (!packedStrokes || !packedStrokes.length) return;
    const s = Number(scale) || 10;
    c.save();
    c.strokeStyle = "#111";
    c.lineCap = "round";
    c.lineJoin = "round";
    const ss = Math.max(sx || 1, sy || 1);
    for (const stroke of packedStrokes) {
      if (!stroke || stroke.length < 6) continue;
      for (let i = 3; i < stroke.length; i += 3) {
        const ax = (stroke[i - 3] || 0) / s;
        const ay = (stroke[i - 2] || 0) / s;
        const aw = (stroke[i - 1] || 20) / s;
        const bx = (stroke[i] || 0) / s;
        const by = (stroke[i + 1] || 0) / s;
        const bw = (stroke[i + 2] || 20) / s;

        const lw = (aw + bw) * 0.5 * ss;
        c.lineWidth = Math.max(1, lw);
        c.beginPath();
        c.moveTo(ax * sx, ay * sy);
        c.lineTo(bx * sx, by * sy);
        c.stroke();
      }
    }
    c.restore();
  }

  canvas.addEventListener("pointerdown", (e) => {
    if (!canDraw()) return;
    e.preventDefault();
    canvas.setPointerCapture(e.pointerId);
    isDrawing = true;
    lastP = getPoint(e);
    currentStroke = [{ x: lastP.x, y: lastP.y, w: lastP.w }];
    strokes.push(currentStroke);
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!isDrawing || !lastP || !canDraw()) return;
    e.preventDefault();
    const p = getPoint(e);
    const dx = p.x - lastP.x;
    const dy = p.y - lastP.y;
    if ((dx*dx + dy*dy) < 0.25) return; // ignore jitter (<0.5px)
    ctx.strokeStyle = "#111";
    ctx.lineWidth = p.w;
    ctx.beginPath();
    ctx.moveTo(lastP.x, lastP.y);
    ctx.lineTo(p.x, p.y);
    ctx.stroke();
    hasInk = true;
    lastP = p;
    if (currentStroke) currentStroke.push({ x: p.x, y: p.y, w: p.w });
  });

  function endDraw(e) {
    if (!isDrawing) return;
    e.preventDefault();
    isDrawing = false;
    lastP = null;
    currentStroke = null;
  }
  canvas.addEventListener("pointerup", endDraw);
  canvas.addEventListener("pointercancel", endDraw);
  canvas.addEventListener("pointerleave", endDraw);

  function clearPad() {
    // clear in CSS pixel coords (ctx transform is scaled to DPR)
    ctx.clearRect(0, 0, canvasCssW, canvasCssH);
    hasInk = false;
    strokes = [];
    currentStroke = null;
  }

  // ---- Game flow ----
  function renderQuestion() {
    const q = questions[qi];
    jpEl.textContent = (running && !revealed) ? `${q.jp}` : "";
    revealEl.textContent = "";
    revealEl.classList.remove("shown");
    revealed = false;

    
    loggedThis = false;
timeLeftMs = 10_000;
    lastTick = null;
    timerEl.textContent = `${(timeLeftMs/1000).toFixed(1)}s`;

    correctBtn.disabled = true;
    wrongBtn.disabled = true;
    clearPad();
    syncUiState();
  }

  function revealAnswer() {
    revealed = true;
    const q = questions[qi];
    revealEl.textContent = `${q.en}`;
    revealEl.classList.add("shown");

    correctBtn.disabled = false;
    wrongBtn.disabled = false;
    // optional: stop drawing immediately by setting revealed=true (handled by canDraw())
    syncUiState();
  }

  function setStats() {
    statsEl.textContent = `Score: ${correct} / ${total} | Streak: ${streak}`;
  }

  function tick(ts) {
    if (!running) return;
    if (lastTick == null) lastTick = ts;
    const dt = ts - lastTick;
    lastTick = ts;

    timeLeftMs = Math.max(0, timeLeftMs - dt);
    timerEl.textContent = `${(timeLeftMs/1000).toFixed(1)}s`;

    if (timeLeftMs <= 0 && !revealed) {
      running = false;
      revealAnswer();
      return;
    }

    rafId = requestAnimationFrame(tick);
  }

  function startTimer() {
    if (revealed) return; // don't restart after reveal
    if (running) return;
    running = true;
    everStarted = true;
    // Safety: close handwriting preview if open
    if (inkModal && !inkModal.hidden) closeInk();
    syncUiState();
    rafId = requestAnimationFrame(tick);
  }

  function stopTimer() {
    running = false;
    syncUiState();
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
    lastTick = null;
  }


  // Finish the timer early (used when the user doesn't need the full time)
  function finishTimerEarly() {
    if (!running || revealed) return;
    timeLeftMs = 0;
    timerEl.textContent = `0.0s`;
    running = false;
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
    lastTick = null;
    revealAnswer();
  }


  function nextRoundAndStart() {
    // Advance to the next prompt and immediately start the countdown
    stopTimer();
    qi = (qi + 1) % questions.length;
    if (qi === 0) shuffleQuestions(questions);
    renderQuestion();
    startTimer();
  }


  // ---- Buttons ----
  // On narrow screens the Control panel may be below the fold,
  // so provide a Start button in the Timer block and on the pad overlay.
  if (startBtnMain) {
    startBtnMain.addEventListener("click", () => {
      // START (idle) -> begin writing
      // NEXT (after self-check) -> advance and immediately start the next round
      if (running && !revealed) {
        finishTimerEarly();
        return;
      }
      if (running) return;
      if (revealed) {
        if (!loggedThis) return; // must choose Correct/Wrong first
        nextRoundAndStart();
        return;
      }
      startTimer();
    });
  }
  if (overlayStartBtn) {
    overlayStartBtn.addEventListener("click", () => {
      if (!running && !revealed) startTimer();
    });
  }

  if (padClearBtn) {
    padClearBtn.addEventListener("click", () => {
      if (!running || revealed) return;
      clearPad();
    });
  }

  if (clearHistoryBtn) {
    clearHistoryBtn.addEventListener("click", () => {
      const ok = confirm("Clear history? This will remove saved handwriting and reset Score/Streak.");
      if (!ok) return;
      history = [];
      try { localStorage.removeItem(HISTORY_KEY); } catch (e) {}
      if (inkModal && !inkModal.hidden) closeInk();
      renderHistory();
      recomputeStatsFromHistory();
      syncUiState();
    });
  }


  correctBtn.addEventListener("click", () => {
    if (!revealed) return;
    logCurrentIfNeeded("correct");
    syncUiState();
    correctBtn.disabled = true;
    wrongBtn.disabled = true;
  });

  wrongBtn.addEventListener("click", () => {
    if (!revealed) return;
    logCurrentIfNeeded("wrong");
    syncUiState();
    correctBtn.disabled = true;
    wrongBtn.disabled = true;
  });
// init
  shuffleQuestions(questions);
  recomputeStatsFromHistory();
  renderQuestion();
  renderHistory();
  syncUiState();
})();
</script></body>
</html>
